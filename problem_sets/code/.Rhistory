knitr::opts_chunk$set(echo = TRUE)
# Setting objects
c = matrix(c(12547, 4818, 3440, 8583, 6657, 4990, 14493, 7990, 6139, 7043, 3758, 1487, 13238, 11033, 4921),
nrow = 5,
ncol = 3,
byrow = TRUE)
View(c)
p = c(1.05, 1.04, 1.1)
r = c(1.1, 1.09, 1.14)
alpha = 0.18
g_bar_1 = function(beta) {
moment = 0
for (i in 1:nrow(c)) {
c_1 = c[i, 1]
c_2 = c[i, 2]
p_1 = p[1]
r_2 = r[2]
moment = moment + (p_1 * c_1^(-alpha) - beta * r_2 * c_2^(-alpha))
}
return(moment/(nrow(c)))
}
g_bar_2 = function(beta) {
moment = 0
for (i in 1:nrow(c)) {
c_2 = c[i, 2]
c_3 = c[i, 3]
p_2 = p[2]
r_3 = r[3]
moment = moment + (p_2 * c_2^(-alpha) - beta * r_3 * c_3^(-alpha))
}
return(moment/(nrow(c)))
}
# Estimating beta using MME
estimate_beta = function() {
beta_hat_1 = uniroot(g_bar_1, c(0, 1))$root
beta_hat_2 = uniroot(g_bar_2, c(0, 1))$root
return(c(beta_hat_1, beta_hat_2))
}
# Beta estimates
beta_estimates = estimate_beta()
beta_estimates
c[1, 2]
knitr::opts_chunk$set(echo = TRUE)
# Setting objects
c = matrix(c(12547, 4818, 3440, 8583, 6657, 4990, 14493, 7990, 6139, 7043, 3758, 1487, 13238, 11033, 4921),
nrow = 5,
ncol = 3,
byrow = TRUE)
p = c(1.05, 1.04, 1.1)
r = c(1.1, 1.09, 1.14)
alpha = 0.18
g_bar_1 = function(beta_1) {
moment = 0
for (i in 1:nrow(c)) {
c_1 = c[i, 1]
c_2 = c[i, 2]
p_1 = p[1]
r_2 = r[2]
moment = moment + (p_1 * c_1^(-alpha) - beta_1 * r_2 * c_2^(-alpha))
}
return(moment/(nrow(c)))
}
g_bar_2 = function(beta_2) {
moment = 0
for (i in 1:nrow(c)) {
c_2 = c[i, 2]
c_3 = c[i, 3]
p_2 = p[2]
r_3 = r[3]
moment = moment + (p_2 * c_2^(-alpha) - beta_2 * r_3 * c_3^(-alpha))
}
return(moment/(nrow(c)))
}
# Estimating beta using MME
estimate_beta = function() {
beta_hat_1 = uniroot(g_bar_1, c(0, 1))$root
beta_hat_2 = uniroot(g_bar_2, c(0, 1))$root
return(c(beta_hat_1, beta_hat_2))
}
# Beta estimates
beta_estimates = estimate_beta()
beta_estimates
View(c)
sum(p)
1 = p
p[4]
p[4] = 1
p[4] = NULL
p = p[-4]
beta_1 = c()
beta_1[1] = 1
beta_1[2] = 2
c[, 1]
beta_1 = c()
for (i in 1:nrow(c)) {
c_1 = c[i, 1]
c_2 = c[i, 2]
p_1 = p[1]
r_2 = r[2]
beta_1[i] = (p_1*c_1^(-alpha))/(r_2*c_2^(-alpha))
}
beta_hat_1 = sum(beta_1)/length(beta_1)
beta_2 = c()
for (i in 1:nrow(c)) {
c_2 = c[i, 2]
c_3 = c[i, 3]
p_2 = p[2]
r_3 = r[3]
beta_2[i] = (p_2*c_2^(-alpha))/(r_3*c_3^(-alpha))
}
beta_hat_2 = sum(beta_2)/length(beta_2)
# Beta estimates
print(beta_hat_1, beta_hat_2)
# Setting objects
c = matrix(c(12547, 4818, 3440, 8583, 6657, 4990, 14493, 7990, 6139, 7043, 3758, 1487, 13238, 11033, 4921),
nrow = 5,
ncol = 3,
byrow = TRUE)
p = c(1.05, 1.04, 1.1)
r = c(1.1, 1.09, 1.14)
alpha = 0.18
# Estimating beta using MME
beta_1 = c()
for (i in 1:nrow(c)) {
c_1 = c[i, 1]
c_2 = c[i, 2]
p_1 = p[1]
r_2 = r[2]
beta_1[i] = (p_1*c_1^(-alpha))/(r_2*c_2^(-alpha))
}
beta_hat_1 = sum(beta_1)/length(beta_1)
beta_2 = c()
for (i in 1:nrow(c)) {
c_2 = c[i, 2]
c_3 = c[i, 3]
p_2 = p[2]
r_3 = r[3]
beta_2[i] = (p_2*c_2^(-alpha))/(r_3*c_3^(-alpha))
}
beta_hat_2 = sum(beta_2)/length(beta_2)
# Beta estimates
print(beta_hat_1, beta_hat_2)
# Beta estimates
print(c(beta_hat_1, beta_hat_2))
pacman::p_load(
here
)
iv_data = readRDS(here('data', 'iv_data.rds'))
iv_data = readRDS(here("data", "iv_data.rds"))
here("data", "iv_data.rds")
path_iv_data = here("data", "iv_data.rds")
iv_data = readRDS(path_iv_data)
path_iv_data
iv_data = readRDS("C:/Users/gusta/OneDrive - Fundacao Getulio Vargas - FGV/Área de Trabalho/EPGE - MATERIAL/Econometria I/Parte 1/Programação/econometricsI_epge/data/iv_data.rds")
iv_data = readRDS("C://Users//gusta/OneDrive - Fundacao Getulio Vargas - FGV//Área de Trabalho//EPGE - MATERIAL//Econometria I//Parte 1//Programação//econometricsI_epge//data//iv_data.rds")
iv_data = readRDS("C:\Users\gusta/OneDrive - Fundacao Getulio Vargas - FGV\Área de Trabalho\EPGE - MATERIAL\Econometria I\Parte 1\Programação\econometricsI_epge\data\iv_data.rds")
iv_data = readRDS(here("data", "iv_data.Rds"))
iv_data = readRDS(here("data", "iv_data.Rds"))
iv_data = readRDS(here("data", "iv_data.Rds"))
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(
here
)
iv_data = readRDS(here("data", "iv_data.Rds"))
iv_data = readRDS(here("data", "iv_data.rds"))
readRDS(here("data", "iv_data.rds"))
iv_df = readRDS(here("data", "iv_data.rds"))
readRDS(here("data", "iv_data.rds"))
iv_data <- readRDS("C:/Users/gusta/OneDrive - Fundacao Getulio Vargas - FGV/Área de Trabalho/EPGE - MATERIAL/Econometria I/Parte 1/Programação/econometricsI_epge/problem_sets/data/iv_data.Rds")
View(iv_data)
iv_df = readRDS(here("data", "iv_data.rds"))
iv_data = readRDS(here("data", "iv_data.Rds"))
iv_data <- readRDS("C:/Users/gusta/OneDrive - Fundacao Getulio Vargas - FGV/Área de Trabalho/EPGE - MATERIAL/Econometria I/Parte 1/Programação/econometricsI_epge/problem_sets/data/iv_data.Rds")
iv_data = readRDS(here("problem_sets", "iv_data.Rds"))
write.csv(iv_data, here("data", "iv_data.Rds"), row.names = F)
iv_data = readRDS(here("problem_sets/data", "iv_data.Rds"))
iv_data = readRDS(here("problem_sets/data", "iv_data.Rds"))
View(iv_data)
View(iv_data)
# Seting the variables
y = iv_data[, 1] # Dependent variable
x = as.matrix(iv_data[, 2:3]) # Endogenous variables
View(x)
z = as.matrix(iv_data[, 4:6]) # Instruments
# Minimizing the objective function
result = optim(par = c(0, 0), fn = J_beta)
# Defining the moment function and the objective function
g_n = function(beta){
u = y - x%*%beta
g_n_beta = colMeans(z*u)
return(g_n_beta)
}
J_beta = function(beta){
g_n_beta = g_n(beta)
return(t(g_n_beta) %*% g_n_beta)
}
# Minimizing the objective function
result = optim(par = c(0, 0), fn = J_beta)
View(z)
# Defining the moment function and the objective function
g_n = function(beta){
u = y - x%*%beta
g_n_beta = colMeans(t(z)*u)
return(g_n_beta)
}
J_beta = function(beta){
g_n_beta = g_n(beta)
return(t(g_n_beta) %*% g_n_beta)
}
# Minimizing the objective function
result = optim(par = c(0, 0), fn = J_beta)
# Defining the moment function and the objective function
g_n = function(beta){
u = y - x%*%beta
g_n_beta = colMeans(z*t(u))
return(g_n_beta)
}
J_beta = function(beta){
g_n_beta = g_n(beta)
return(t(g_n_beta) %*% g_n_beta)
}
# Minimizing the objective function
result = optim(par = c(0, 0), fn = J_beta)
u = y - x%*%beta
# Seting the variables
y = iv_data[, 1] # Dependent variable
x = as.matrix(iv_data[, 2:3]) # Endogenous variables
z = as.matrix(iv_data[, 4:6]) # Instruments
# Defining the moment function and the objective function
g_n = function(beta){
u = y - x%*%beta
g_n_beta = colMeans(z*t(u))
return(g_n_beta)
}
J_beta = function(beta){
g_n_beta = g_n(beta)
return(t(g_n_beta) %*% g_n_beta)
}
# Minimizing the objective function
result = optim(par = c(0, 0), fn = J_beta)
# Defining the moment function and the objective function
g_n = function(beta){
u = y - x%*%beta
g_n_beta = colMeans(sweep(z, 1, u, `*`))
return(g_n_beta)
}
J_beta = function(beta){
g_n_beta = g_n(beta)
return(t(g_n_beta) %*% g_n_beta)
}
# Minimizing the objective function
result = optim(par = c(0, 0), fn = J_beta)
# Printing the result
beta_hat = result$par
objective_value = result$value
cat("Beta estimates:", beta_hat, "\n")
cat("Objective function value:", objective_value, "\n")
cat("Beta estimates:", beta_hat, "\n")
cat("Beta's estimate:", beta_hat, "\n")
cat("Objective function value:", objective_value, "\n")
# Calculating S_hat
S_hat = matrix(0, ncol = 3, nrow = 3)
for (i in 1:nrow(iv_data)) {
g_i_beta_hat = g_i(i, beta_hat)
S_hat = S_hat + g_i_beta_hat %*% t(g_i_beta_hat)
}
# Defining the "g_i" function for each observation i
g_i = function(i, beta){
u_i = y[i] - x[i, ] %*% beta
g_i_beta = z[i, ] * u_i
return(g_i_beta)
}
for (i in 1:nrow(iv_data)) {
g_i_beta_hat = g_i(i, beta_hat)
S_hat = S_hat + g_i_beta_hat %*% t(g_i_beta_hat)
}
S_hat = S_hat/nrow(iv_data)
View(S_hat)
# Defining the "g_i" function for each observation i
g_i = function(i, beta){
u_i = as.numeric(y[i] - x[i, ] %*% beta)
g_i_beta = z[i, ] * u_i
return(g_i_beta)
}
# Calculating S_hat
S_hat = matrix(0, ncol = 3, nrow = 3)
for (i in 1:nrow(iv_data)) {
g_i_beta_hat = g_i(i, beta_hat)
S_hat = S_hat + g_i_beta_hat %*% t(g_i_beta_hat)
}
S_hat = S_hat/nrow(iv_data)
cat("S_hat estimate:", S_hat, "\n")
cat("S_hat estimate:", print(S_hat), "\n")
cat("S_hat estimate:", print(S_hat), "\n")
S_hat
# Redefining the objective function using S_hat
J_beta_optimal = function(beta){
g_n_beta = g_n(beta)
return(t(g_n_beta) %*% solve(S_hat) %*% g_n_beta)
}
# Redefining the objective function using S_hat
J_beta_opt = function(beta){
g_n_beta = g_n(beta)
return(t(g_n_beta) %*% solve(S_hat) %*% g_n_beta)
}
rm(J_beta_optimal())
rm(J_beta_optimal())
# Minimizing the objective function
result_opt = optim(par = c(0, 0), fn = J_beta_opt())
# Minimizing the objective function
result_opt = optim(par = c(0, 0), fn = J_beta_opt)
# Printing the result
beta_hat_opt = result_opt$par
cat("Beta estimate:", beta_hat_opt, "\n")
# Defining the Jacobian G_n(β)
G_n = function(beta) {
n = nrow(iv_data)         # Nº of observations
g_n_beta = g_n(beta)      # Calculating g_n(β)
# Initialize the Jacobian matrix G_n(β)
G_n_matrix = matrix(0, nrow = 3, ncol = 2)
# Calculating the Jacobian
for (i in 1:n) {
u_i = y[i] - x[i, ] %*% beta
for (j in 1:2) {
# Partial derivatives of g_n(β) with respect to β_j
G_n_matrix[, j] = G_n_matrix[, j] + z[i, ] * (-x[i, j]) * (1/n)
}
}
return(G_n_matrix)
}
# Calculate the Jacobian in beta_hat
G_hat = G_n(beta_hat)
# Result
cat("Jacobian G_hat:", G_hat, "\n")
# Result
cat("Jacobian G_hat:\n")
print(G_hat)
cat("S_hat:\n")
S_hat
# Result
cat("Jacobian G_hat:\n")
G_hat
# Redefining the objective function using S_hat
S_hat_inv = solve(S_hat)
# Calculating the product G_hat' S_hat^{-1} G_hat
G_hat_transpose = t(G_hat)
product = G_hat_transpose %*% S_hat_inv %*% G_hat
# Calculating the covariance matrix V^{GMM}
V_GMM = (1/n) * solve(product)
n = nrow(iv_data) # Nº of observations
# Calculating the covariance matrix V^{GMM}
V_GMM = (1/n) * solve(product)
# Resultado
cat("Estimated covariance matrix V_GMM:\n")
V_GMM
pacman::p_load(
fixest
)
temperature_states = readRDS(here("problem_sets/data", "temperature_states.Rds"))
View(temperature_states)
temperature = readRDS(here("problem_sets/data", "temperature.Rds"))
View(temperature)
pacman::p_load(
tydiverse,
fixest
)
pacman::p_load(
tidyverse,
fixest
)
# Step 1: Calculate the national average daily maximum temperature
national_avg_temp = temperature_states %>%
group_by(date) %>% # Group by date
# Calculate the average max temperature
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE))
# Step 2: Count the number of days with average temperature above 32°C per year-month
days_above_32C = national_avg_temp %>%
mutate(year_month = format(data, "%Y-%m")) %>% # Create a year-month column
filter(avg_temp > 32) %>%                     # Filter for temperatures above 32°C
group_by(year_month) %>%                      # Group by year-month
summarise(days_above_32C = n())               # Count the days
temperature_states = readRDS(here("problem_sets/data", "temperature_states.Rds")) %>%
mutate(date = as.Date(date, format = "%Y-%m-%d"))
# Step 1: Calculate the national average daily maximum temperature
national_avg_temp = temperature_states %>%
group_by(date) %>% # Group by date
# Calculate the average max temperature
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE))
# Step 2: Count the number of days with average temperature above 32°C per year-month
days_above_32C = national_avg_temp %>%
mutate(year_month = format(data, "%Y-%m")) %>% # Create a year-month column
filter(avg_temp > 32) %>%                     # Filter for temperatures above 32°C
group_by(year_month) %>%                      # Group by year-month
summarise(days_above_32C = n())               # Count the days
View(national_avg_temp)
# Step 1: Calculate the national average daily maximum temperature
national_avg_temp = temperature_states %>%
group_by(date) %>% # Group by date
# Calculate the average max temperature
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE)) %>%
mutate(date = as.Date(date, format = "%Y-%m-%d"))
# Step 2: Count the number of days with average temperature above 32°C per year-month
days_above_32C = national_avg_temp %>%
mutate(year_month = format(date, "%Y-%m")) %>% # Create a year-month column
filter(avg_temp > 32) %>%                     # Filter for temperatures above 32°C
group_by(year_month) %>%                      # Group by year-month
summarise(days_above_32C = n())               # Count the days
# Step 1: Calculate the national average daily maximum temperature
national_avg_temp = temperature_states %>%
group_by(date) %>% # Group by date
# Calculate the average max temperature
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE))
# Step 2: Count the number of days with average temperature above 32°C per year-month
days_above_32C = national_avg_temp %>%
mutate(year_month = format(date, "%Y-%m")) %>% # Create a year-month column
filter(avg_temp > 32) %>%                     # Filter for temperatures above 32°C
group_by(year_month) %>%                      # Group by year-month
summarise(days_above_32C = n())               # Count the days
View(days_above_32C)
# Step 3: Regression of the count of days above 32°C on calendar year with month fixed effects
# Add a column for the year
days_above_32C = days_above_32C %>%
mutate(year = as.numeric(substring(year_month, 1, 4))) # Extract the year
# Perform regression using fixest
model = feols(days_above_32C ~ year | month(year_month), data = days_above_32C)
# Step 3: Regression of the count of days above 32°C on calendar year with month fixed effects
# Add columns for the year and month
days_above_32C = days_above_32C %>%
mutate(year = as.numeric(substring(year_month, 1, 4)),
month = as.numeric(substring(year_month, 6, 7))) # Extract the year
# Perform regression using fixest
model = feols(days_above_32C ~ year | month, data = days_above_32C)
# Display regression results
summary(model)
model$coefficients
pacman::p_load(
tidyverse,
fixest
)
temperature_states = readRDS(here("problem_sets/data", "temperature_states.Rds"))
# Step 1: Calculate the national average daily maximum temperature
national_avg_temp = temperature_states %>%
group_by(date) %>% # Group by date
# Calculate the average max temperature
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE))
# Step 2: Count the number of days with average temperature above 32°C per year-month
days_above_32C = national_avg_temp %>%
mutate(year_month = format(date, "%Y-%m")) %>% # Create a year-month column
filter(avg_temp > 32) %>%                     # Filter for temperatures above 32°C
group_by(year_month) %>%                      # Group by year-month
summarise(days_above_32C = n())               # Count the days
# Step 3: Regression of the count of days above 32°C on calendar year with month fixed effects
# Add columns for the year and month
days_above_32C = days_above_32C %>%
mutate(year = as.numeric(substring(year_month, 1, 4)),
month = as.numeric(substring(year_month, 6, 7)))
# Perform regression using fixest
model = feols(days_above_32C ~ year | month, data = days_above_32C)
# Display regression results
summary(model)
# Step 4: Repeat the analysis for each region
results_by_region = lapply(unique(temperature_states$region), function(region) {
# Filter the data for the specific region
region_data = temperature_states %>%
filter(region == region)                    # Keep only the rows for the current region
# Calculate the average daily temperature for the region
region_avg_temp = region_data %>%
group_by(date) %>%                          # Group by date
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE)) # Calculate average max temperature for the region
# Count the number of days with average temperature above 32°C per year-month for the region
region_days_above_32C = region_avg_temp %>%
mutate(year_month = format(date, "%Y-%m")) %>% # Create a year-month column
filter(avg_temp > 32) %>%                     # Filter for temperatures above 32°C
group_by(year_month) %>%                      # Group by year-month
summarise(days_above_32C = n())               # Count the days
# Add columns for the year and month
region_days_above_32C = region_days_above_32C %>%
mutate(year = as.numeric(substring(year_month, 1, 4)),
month = as.numeric(substring(year_month, 6, 7)))
# Perform regression for the region
model_region = feols(days_above_32C ~ year | month,
data = region_days_above_32C)
# Return the region name and model
return(list(region = region, model = model_region))
})
# Display results by region
results_by_region
