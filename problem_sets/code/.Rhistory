# Defining the moment function and the objective function
g_n = function(beta){
u = y - x%*%beta
g_n_beta = colMeans(t(z)*u)
return(g_n_beta)
}
J_beta = function(beta){
g_n_beta = g_n(beta)
return(t(g_n_beta) %*% g_n_beta)
}
# Minimizing the objective function
result = optim(par = c(0, 0), fn = J_beta)
# Defining the moment function and the objective function
g_n = function(beta){
u = y - x%*%beta
g_n_beta = colMeans(z*t(u))
return(g_n_beta)
}
J_beta = function(beta){
g_n_beta = g_n(beta)
return(t(g_n_beta) %*% g_n_beta)
}
# Minimizing the objective function
result = optim(par = c(0, 0), fn = J_beta)
u = y - x%*%beta
# Seting the variables
y = iv_data[, 1] # Dependent variable
x = as.matrix(iv_data[, 2:3]) # Endogenous variables
z = as.matrix(iv_data[, 4:6]) # Instruments
# Defining the moment function and the objective function
g_n = function(beta){
u = y - x%*%beta
g_n_beta = colMeans(z*t(u))
return(g_n_beta)
}
J_beta = function(beta){
g_n_beta = g_n(beta)
return(t(g_n_beta) %*% g_n_beta)
}
# Minimizing the objective function
result = optim(par = c(0, 0), fn = J_beta)
# Defining the moment function and the objective function
g_n = function(beta){
u = y - x%*%beta
g_n_beta = colMeans(sweep(z, 1, u, `*`))
return(g_n_beta)
}
J_beta = function(beta){
g_n_beta = g_n(beta)
return(t(g_n_beta) %*% g_n_beta)
}
# Minimizing the objective function
result = optim(par = c(0, 0), fn = J_beta)
# Printing the result
beta_hat = result$par
objective_value = result$value
cat("Beta estimates:", beta_hat, "\n")
cat("Objective function value:", objective_value, "\n")
cat("Beta estimates:", beta_hat, "\n")
cat("Beta's estimate:", beta_hat, "\n")
cat("Objective function value:", objective_value, "\n")
# Calculating S_hat
S_hat = matrix(0, ncol = 3, nrow = 3)
for (i in 1:nrow(iv_data)) {
g_i_beta_hat = g_i(i, beta_hat)
S_hat = S_hat + g_i_beta_hat %*% t(g_i_beta_hat)
}
# Defining the "g_i" function for each observation i
g_i = function(i, beta){
u_i = y[i] - x[i, ] %*% beta
g_i_beta = z[i, ] * u_i
return(g_i_beta)
}
for (i in 1:nrow(iv_data)) {
g_i_beta_hat = g_i(i, beta_hat)
S_hat = S_hat + g_i_beta_hat %*% t(g_i_beta_hat)
}
S_hat = S_hat/nrow(iv_data)
View(S_hat)
# Defining the "g_i" function for each observation i
g_i = function(i, beta){
u_i = as.numeric(y[i] - x[i, ] %*% beta)
g_i_beta = z[i, ] * u_i
return(g_i_beta)
}
# Calculating S_hat
S_hat = matrix(0, ncol = 3, nrow = 3)
for (i in 1:nrow(iv_data)) {
g_i_beta_hat = g_i(i, beta_hat)
S_hat = S_hat + g_i_beta_hat %*% t(g_i_beta_hat)
}
S_hat = S_hat/nrow(iv_data)
cat("S_hat estimate:", S_hat, "\n")
cat("S_hat estimate:", print(S_hat), "\n")
cat("S_hat estimate:", print(S_hat), "\n")
S_hat
# Redefining the objective function using S_hat
J_beta_optimal = function(beta){
g_n_beta = g_n(beta)
return(t(g_n_beta) %*% solve(S_hat) %*% g_n_beta)
}
# Redefining the objective function using S_hat
J_beta_opt = function(beta){
g_n_beta = g_n(beta)
return(t(g_n_beta) %*% solve(S_hat) %*% g_n_beta)
}
rm(J_beta_optimal())
rm(J_beta_optimal())
# Minimizing the objective function
result_opt = optim(par = c(0, 0), fn = J_beta_opt())
# Minimizing the objective function
result_opt = optim(par = c(0, 0), fn = J_beta_opt)
# Printing the result
beta_hat_opt = result_opt$par
cat("Beta estimate:", beta_hat_opt, "\n")
# Defining the Jacobian G_n(β)
G_n = function(beta) {
n = nrow(iv_data)         # Nº of observations
g_n_beta = g_n(beta)      # Calculating g_n(β)
# Initialize the Jacobian matrix G_n(β)
G_n_matrix = matrix(0, nrow = 3, ncol = 2)
# Calculating the Jacobian
for (i in 1:n) {
u_i = y[i] - x[i, ] %*% beta
for (j in 1:2) {
# Partial derivatives of g_n(β) with respect to β_j
G_n_matrix[, j] = G_n_matrix[, j] + z[i, ] * (-x[i, j]) * (1/n)
}
}
return(G_n_matrix)
}
# Calculate the Jacobian in beta_hat
G_hat = G_n(beta_hat)
# Result
cat("Jacobian G_hat:", G_hat, "\n")
# Result
cat("Jacobian G_hat:\n")
print(G_hat)
cat("S_hat:\n")
S_hat
# Result
cat("Jacobian G_hat:\n")
G_hat
# Redefining the objective function using S_hat
S_hat_inv = solve(S_hat)
# Calculating the product G_hat' S_hat^{-1} G_hat
G_hat_transpose = t(G_hat)
product = G_hat_transpose %*% S_hat_inv %*% G_hat
# Calculating the covariance matrix V^{GMM}
V_GMM = (1/n) * solve(product)
n = nrow(iv_data) # Nº of observations
# Calculating the covariance matrix V^{GMM}
V_GMM = (1/n) * solve(product)
# Resultado
cat("Estimated covariance matrix V_GMM:\n")
V_GMM
pacman::p_load(
fixest
)
temperature_states = readRDS(here("problem_sets/data", "temperature_states.Rds"))
View(temperature_states)
temperature = readRDS(here("problem_sets/data", "temperature.Rds"))
View(temperature)
pacman::p_load(
tydiverse,
fixest
)
pacman::p_load(
tidyverse,
fixest
)
# Step 1: Calculate the national average daily maximum temperature
national_avg_temp = temperature_states %>%
group_by(date) %>% # Group by date
# Calculate the average max temperature
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE))
# Step 2: Count the number of days with average temperature above 32°C per year-month
days_above_32C = national_avg_temp %>%
mutate(year_month = format(data, "%Y-%m")) %>% # Create a year-month column
filter(avg_temp > 32) %>%                     # Filter for temperatures above 32°C
group_by(year_month) %>%                      # Group by year-month
summarise(days_above_32C = n())               # Count the days
temperature_states = readRDS(here("problem_sets/data", "temperature_states.Rds")) %>%
mutate(date = as.Date(date, format = "%Y-%m-%d"))
# Step 1: Calculate the national average daily maximum temperature
national_avg_temp = temperature_states %>%
group_by(date) %>% # Group by date
# Calculate the average max temperature
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE))
# Step 2: Count the number of days with average temperature above 32°C per year-month
days_above_32C = national_avg_temp %>%
mutate(year_month = format(data, "%Y-%m")) %>% # Create a year-month column
filter(avg_temp > 32) %>%                     # Filter for temperatures above 32°C
group_by(year_month) %>%                      # Group by year-month
summarise(days_above_32C = n())               # Count the days
View(national_avg_temp)
# Step 1: Calculate the national average daily maximum temperature
national_avg_temp = temperature_states %>%
group_by(date) %>% # Group by date
# Calculate the average max temperature
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE)) %>%
mutate(date = as.Date(date, format = "%Y-%m-%d"))
# Step 2: Count the number of days with average temperature above 32°C per year-month
days_above_32C = national_avg_temp %>%
mutate(year_month = format(date, "%Y-%m")) %>% # Create a year-month column
filter(avg_temp > 32) %>%                     # Filter for temperatures above 32°C
group_by(year_month) %>%                      # Group by year-month
summarise(days_above_32C = n())               # Count the days
# Step 1: Calculate the national average daily maximum temperature
national_avg_temp = temperature_states %>%
group_by(date) %>% # Group by date
# Calculate the average max temperature
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE))
# Step 2: Count the number of days with average temperature above 32°C per year-month
days_above_32C = national_avg_temp %>%
mutate(year_month = format(date, "%Y-%m")) %>% # Create a year-month column
filter(avg_temp > 32) %>%                     # Filter for temperatures above 32°C
group_by(year_month) %>%                      # Group by year-month
summarise(days_above_32C = n())               # Count the days
View(days_above_32C)
# Step 3: Regression of the count of days above 32°C on calendar year with month fixed effects
# Add a column for the year
days_above_32C = days_above_32C %>%
mutate(year = as.numeric(substring(year_month, 1, 4))) # Extract the year
# Perform regression using fixest
model = feols(days_above_32C ~ year | month(year_month), data = days_above_32C)
# Step 3: Regression of the count of days above 32°C on calendar year with month fixed effects
# Add columns for the year and month
days_above_32C = days_above_32C %>%
mutate(year = as.numeric(substring(year_month, 1, 4)),
month = as.numeric(substring(year_month, 6, 7))) # Extract the year
# Perform regression using fixest
model = feols(days_above_32C ~ year | month, data = days_above_32C)
# Display regression results
summary(model)
model$coefficients
pacman::p_load(
tidyverse,
fixest
)
temperature_states = readRDS(here("problem_sets/data", "temperature_states.Rds"))
# Step 1: Calculate the national average daily maximum temperature
national_avg_temp = temperature_states %>%
group_by(date) %>% # Group by date
# Calculate the average max temperature
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE))
# Step 2: Count the number of days with average temperature above 32°C per year-month
days_above_32C = national_avg_temp %>%
mutate(year_month = format(date, "%Y-%m")) %>% # Create a year-month column
filter(avg_temp > 32) %>%                     # Filter for temperatures above 32°C
group_by(year_month) %>%                      # Group by year-month
summarise(days_above_32C = n())               # Count the days
# Step 3: Regression of the count of days above 32°C on calendar year with month fixed effects
# Add columns for the year and month
days_above_32C = days_above_32C %>%
mutate(year = as.numeric(substring(year_month, 1, 4)),
month = as.numeric(substring(year_month, 6, 7)))
# Perform regression using fixest
model = feols(days_above_32C ~ year | month, data = days_above_32C)
# Display regression results
summary(model)
# Step 4: Repeat the analysis for each region
results_by_region = lapply(unique(temperature_states$region), function(region) {
# Filter the data for the specific region
region_data = temperature_states %>%
filter(region == region)                    # Keep only the rows for the current region
# Calculate the average daily temperature for the region
region_avg_temp = region_data %>%
group_by(date) %>%                          # Group by date
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE)) # Calculate average max temperature for the region
# Count the number of days with average temperature above 32°C per year-month for the region
region_days_above_32C = region_avg_temp %>%
mutate(year_month = format(date, "%Y-%m")) %>% # Create a year-month column
filter(avg_temp > 32) %>%                     # Filter for temperatures above 32°C
group_by(year_month) %>%                      # Group by year-month
summarise(days_above_32C = n())               # Count the days
# Add columns for the year and month
region_days_above_32C = region_days_above_32C %>%
mutate(year = as.numeric(substring(year_month, 1, 4)),
month = as.numeric(substring(year_month, 6, 7)))
# Perform regression for the region
model_region = feols(days_above_32C ~ year | month,
data = region_days_above_32C)
# Return the region name and model
return(list(region = region, model = model_region))
})
# Display results by region
results_by_region
knitr::opts_chunk$set(echo = TRUE)
pacman::p_load(
tidyverse,
fixest
)
# Load your data
temperature_states = readRDS(here("problem_sets/data", "temperature_states.Rds"))
library(here)
pacman::p_load(
tidyverse,
fixest
)
# Load your data
temperature_states = readRDS(here("problem_sets/data", "temperature_states.Rds"))
# Filter for the years 2001-2004
filtered_data <- temperature_states %>%
filter(year >= 2001 & year <= 2004)
# Calculate average maximum temperature (tmax) per month and state
monthly_avg_tmax <- filtered_data %>%
group_by(state, month) %>%
summarise(avg_tmax = mean(tmax, na.rm = TRUE)) %>%
ungroup()
pacman::p_load(
tidyverse,
fixest
)
# Load your data
temperature_states = readRDS(here("problem_sets/data", "temperature_states.Rds"))
# Filter for the years 2001-2004
filtered_data <- temperature_states %>%
filter(year >= 2001 & year <= 2004)
# Calculate average maximum temperature (tmax) per month and state
monthly_avg_tmax <- filtered_data %>%
group_by(state, month) %>%
summarise(avg_temp = mean(tmax, na.rm = TRUE)) %>%
ungroup()
pacman::p_load(
tidyverse,
fixest
)
# Load your data
temperature_states = readRDS(here("problem_sets/data", "temperature_states.Rds"))
# Filter for the years 2001-2004
filtered_data <- temperature_states %>%
filter(year >= 2001 & year <= 2004)
# Calculate average maximum temperature (tmax) per month and state
monthly_avg_tmax <- filtered_data %>%
group_by(state, month) %>%
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE)) %>%
ungroup()
# Calculate kernel density estimation
kde <- density(monthly_avg_tmax$avg_tmax, bw = 2)
pacman::p_load(
tidyverse,
fixest
)
# Load your data
temperature_states = readRDS(here("problem_sets/data", "temperature_states.Rds"))
# Filter for the years 2001-2004
filtered_data <- temperature_states %>%
filter(year >= 2001 & year <= 2004)
# Calculate average maximum temperature (tmax) per month and state
monthly_avg_tmax <- filtered_data %>%
group_by(state, month) %>%
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE)) %>%
ungroup()
# Calculate kernel density estimation
kde <- density(monthly_avg_tmax$avg_temp, bw = 2)
# Convert to data frame for plotting
kde_df <- data.frame(x = kde$x, y = kde$y)
# Plot the kernel density estimate
ggplot(kde_df, aes(x = x, y = y)) +
geom_line(color = "blue") +
labs(title = "Kernel Density Estimation of Average Monthly Tmax (2001-2004)",
x = "Average Monthly Tmax",
y = "Density") +
theme_minimal()
help("density")
pacman::p_load(
tidyverse,
fixest
)
# Load your data
temperature_states = readRDS(here("problem_sets/data", "temperature_states.Rds"))
# Filter for the years 2001-2004
filtered_data <- temperature_states %>%
filter(year >= 2018 & year <= 2021)
# Calculate average maximum temperature (tmax) per month and state
monthly_avg_tmax <- filtered_data %>%
group_by(state, month) %>%
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE)) %>%
ungroup()
# Calculate kernel density estimation
kde <- density(monthly_avg_tmax$avg_temp, bw = 2)
# Convert to data frame for plotting
kde_df <- data.frame(x = kde$x, y = kde$y)
# Plot the kernel density estimate
ggplot(kde_df, aes(x = x, y = y)) +
geom_line(color = "blue") +
labs(title = "Kernel Density Estimation of Average Monthly Tmax (2018-2021)",
x = "Average Monthly Tmax",
y = "Density") +
theme_minimal()
pacman::p_load(
tidyverse,
fixest
)
# Load your data
temperature_states = readRDS(here("problem_sets/data", "temperature_states.Rds"))
# Filter for the years 2001-2004
filtered_data <- temperature_states %>%
filter(year >= 2001 & year <= 2004)
# Calculate average maximum temperature (tmax) per month and state
monthly_avg_tmax <- filtered_data %>%
group_by(state, month) %>%
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE)) %>%
ungroup()
# Calculate kernel density estimation
kde <- density(monthly_avg_tmax$avg_temp, bw = 2)
# Convert to data frame for plotting
kde_df <- data.frame(x = kde$x, y = kde$y)
# Plot the kernel density estimate
ggplot(kde_df, aes(x = x, y = y)) +
geom_line(color = "blue") +
labs(title = "Kernel Density Estimation of Average Monthly Tmax (2001-2004)",
x = "Average Monthly Tmax",
y = "Density") +
theme_minimal()
pacman::p_load(
tidyverse,
fixest
)
temperature_states = readRDS(here("problem_sets/data", "temperature_states.Rds"))
# Filter for the years 2001-2004
filtered_data <- temperature_states %>%
filter(year >= 2001 & year <= 2004)
# Calculate average maximum temperature (tmax) per month and state
monthly_avg_tmax <- filtered_data %>%
group_by(state, month) %>%
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE)) %>%
ungroup()
# Calculate kernel density estimation
kde <- density(monthly_avg_tmax$avg_temp, bw = 2)
# Plot
kde_df <- data.frame(x = kde$x, y = kde$y)
ggplot(kde_df, aes(x = x, y = y)) +
geom_line(color = "blue") +
labs(title = "Kernel Density Estimation of Average Monthly Tmax (2001-2004)",
x = "Average Monthly Tmax",
y = "Density") +
theme_minimal()
pacman::p_load(
tidyverse,
fixest
)
temperature_states = readRDS(here("problem_sets/data", "temperature_states.Rds"))
# Filter for the years 2018-2021
filtered_data <- temperature_states %>%
filter(year >= 2018 & year <= 2021)
# Calculate average maximum temperature (tmax) per month and state
monthly_avg_tmax <- filtered_data %>%
group_by(state, month) %>%
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE)) %>%
ungroup()
# Calculate kernel density estimation
kde <- density(monthly_avg_tmax$avg_temp, bw = 2)
# Plot
kde_df <- data.frame(x = kde$x, y = kde$y)
ggplot(kde_df, aes(x = x, y = y)) +
geom_line(color = "blue") +
labs(title = "Kernel Density Estimation of Average Monthly Tmax (2018-2021)",
x = "Average Monthly Tmax",
y = "Density") +
theme_minimal()
View(temperature_states)
print(filtered_data)
pacman::p_load(
tidyverse,
fixest
)
temperature_states = readRDS(here("problem_sets/data", "temperature_states.Rds"))
# Filter for the years 2001-2004
filtered_data <- temperature_states %>%
filter(year >= 2001 & year <= 2004)
# Calculate average maximum temperature (tmax) per month and state
monthly_avg_tmax <- filtered_data %>%
group_by(state, month) %>%
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE)) %>%
ungroup()
# Calculate kernel density estimation
kde <- density(monthly_avg_tmax$avg_temp, bw = 2)
# Plot
kde_df <- data.frame(x = kde$x, y = kde$y)
ggplot(kde_df, aes(x = x, y = y)) +
geom_line(color = "blue") +
labs(title = "Kernel Density Estimation of Average Monthly Tmax (2001-2004)",
x = "Average Monthly Tmax",
y = "Density") +
theme_minimal()
View(filtered_data)
pacman::p_load(
tidyverse,
fixest
)
temperature_states = readRDS(here("problem_sets/data", "temperature_states.Rds"))
# Filter for the years 2018-2021
filtered_data <- temperature_states %>%
filter(year >= 2018 & year <= 2021)
# Calculate average maximum temperature (tmax) per month and state
monthly_avg_tmax <- filtered_data %>%
group_by(state, month) %>%
summarise(avg_temp = mean(mean_tmax, na.rm = TRUE)) %>%
ungroup()
# Calculate kernel density estimation
kde <- density(monthly_avg_tmax$avg_temp, bw = 2)
# Plot
kde_df <- data.frame(x = kde$x, y = kde$y)
ggplot(kde_df, aes(x = x, y = y)) +
geom_line(color = "blue") +
labs(title = "Kernel Density Estimation of Average Monthly Tmax (2018-2021)",
x = "Average Monthly Tmax",
y = "Density") +
theme_minimal()
View(filtered_data)
